This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
config.json
run.ps1
Source/config.ps1
Source/enhance.ps1
Source/watch.ps1
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config.json">
{
  "Backup": {
    "LastBackup": "2025-03-17T19:08:54.3305688-04:00",
    "BackupInterval": 24,
    "MaxBackupSets": 5,
    "Enabled": true
  },
  "Files": {
    "LogFile": "C:\\Users\\jimmy\\Downloads\\MarkSnips\\Logs\\watcher.log",
    "ConfigFile": "C:\\Users\\jimmy\\Downloads\\MarkSnips\\config.json"
  },
  "Folders": {
    "Enhanced": "C:\\Users\\jimmy\\Downloads\\MarkSnips\\Enhanced",
    "Backups": "C:\\Users\\jimmy\\Downloads\\MarkSnips\\Backups",
    "Originals": "C:\\Users\\jimmy\\Downloads\\MarkSnips\\Originals",
    "Logs": "C:\\Users\\jimmy\\Downloads\\MarkSnips\\Logs",
    "Base": "C:\\Users\\jimmy\\Downloads\\MarkSnips"
  },
  "AIPrompts": {
    "FilenamePrompt": "Please create a concise, descriptive filename for this markdown document.\r\nThe filename should:\r\n1. Clearly summarize the main topic of the document\r\n2. Be between 3-7 words\r\n3. Use only lowercase letters, numbers, and hyphens (no spaces)\r\n4. End with .md extension\r\n5. Be a clean, SEO-friendly URL slug\r\n\r\nHere's the document content:\r\n\r\n`markdown\r\n{content}\r\n`\r\n\r\nRespond with ONLY the filename and nothing else.",
    "EnhancementPrompt": "Take the following markdown content and restructure it for better readability, formatting, and consistency:\r\n\r\n`markdown\r\n{content}\r\n`\r"
  },
  "Notifications": {
    "ShowErrorNotifications": true,
    "ShowSuccessNotifications": true,
    "Enabled": true
  },
  "Watcher": {
    "FileTrackingExpiration": 60,
    "FileFilter": "*.md",
    "ProcessingDelay": 2,
    "HeartbeatInterval": 5,
    "PollingInterval": 5
  }
}
</file>

<file path="run.ps1">
<#
.SYNOPSIS
Runs the MarkSnips file watcher script.

.DESCRIPTION
This script is the entry point for the MarkSnips file watcher. It can be used to initialize the configuration, 
create backups, restore from backups, and run the watcher script.

.PARAMETER InitializeConfig
If specified, the script will initialize the configuration file.

.PARAMETER Backup
If specified, the script will create a backup of the MarkSnips data.

.PARAMETER Restore
If specified, the script will restore from a backup.

.PARAMETER RestoreFile
The path to the backup file to restore from.

.PARAMETER Configure
If specified, the script will interactively configure the MarkSnips settings.

.EXAMPLE
.\run.ps1 -InitializeConfig
Initializes the configuration file.
#>
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    [Parameter(Mandatory = $false)]
    [switch]$InitializeConfig,
    
    [Parameter(Mandatory = $false)]
    [switch]$Backup,
    
    [Parameter(Mandatory = $false)]
    [switch]$Restore,
    
    [Parameter(Mandatory = $false)]
    [string]$RestoreFile,
    
    [Parameter(Mandatory = $false)]
    [switch]$Configure
)

# Set base paths
$baseDir = "$env:USERPROFILE\Downloads\MarkSnips"
$sourceDir = Join-Path $baseDir "Source"
$configPath = Join-Path $baseDir "config.json"

# Import config module
$configModule = Join-Path $sourceDir "config.ps1"
if (Test-Path $configModule) {
    . $configModule
} else {
    Write-Error "Configuration module not found at $configModule"
    Write-Error "Please ensure the Source directory contains the required scripts."
    exit 1
}

# Initialize configuration if requested or if no config exists
if ($InitializeConfig -or (-not (Test-Path $configPath))) {
    Write-Host "Initializing configuration..." -ForegroundColor Yellow
    $config = Initialize-MarkSnipsConfig -ConfigPath $configPath
    Write-Host "Configuration initialized at $configPath" -ForegroundColor Green
    
    if (-not $Configure) {
        # If not configuring further, exit
        exit 0
    }
}

# Load existing configuration
$config = Import-MarkSnipsConfig -ConfigPath $configPath

# Interactive configuration
if ($Configure) {
    Write-Host "=== MarkSnips Configuration ===" -ForegroundColor Cyan
    Write-Host "Current configuration loaded from: $configPath" -ForegroundColor Cyan
    
    # Base folder configuration
    $baseFolder = Read-Host "Base folder [$($config.Folders.Base)]"
    if ($baseFolder) {
        $config.Folders.Base = $baseFolder
        $config.Folders.Originals = Join-Path $baseFolder "Originals"
        $config.Folders.Enhanced = Join-Path $baseFolder "Enhanced"
        $config.Folders.Logs = Join-Path $baseFolder "Logs"
        $config.Folders.Backups = Join-Path $baseFolder "Backups"
        $config.Files.LogFile = Join-Path $config.Folders.Logs "watcher.log"
    }
    
    # Backup configuration
    $enableBackups = Read-Host "Enable automatic backups? (Y/N) [$(if ($config.Backup.Enabled) { "Y" } else { "N" })]"
    if ($enableBackups) {
        $config.Backup.Enabled = $enableBackups.ToUpper() -eq "Y"
    }
    
    if ($config.Backup.Enabled) {
        $backupInterval = Read-Host "Backup interval in hours [$($config.Backup.BackupInterval)]"
        if ($backupInterval) {
            $config.Backup.BackupInterval = [int]$backupInterval
        }
        
        $maxBackups = Read-Host "Maximum number of backup sets to keep [$($config.Backup.MaxBackupSets)]"
        if ($maxBackups) {
            $config.Backup.MaxBackupSets = [int]$maxBackups
        }
    }
    
    # Notification configuration
    $enableNotifications = Read-Host "Enable notifications? (Y/N) [$(if ($config.Notifications.Enabled) { "Y" } else { "N" })]"
    if ($enableNotifications) {
        $config.Notifications.Enabled = $enableNotifications.ToUpper() -eq "Y"
    }
    
    # Save the updated configuration
    Export-MarkSnipsConfig -Config $config -ConfigPath $configPath
    Write-Host "Configuration saved successfully." -ForegroundColor Green
    exit 0
}

# Backup functionality
if ($Backup) {
    if ($PSCmdlet.ShouldProcess("MarkSnips data", "Create backup")) {
        Write-Host "Creating backup..." -ForegroundColor Yellow
        $backupFile = Backup-MarkSnipsData -Config $config
        if ($backupFile) {
            Write-Host "Backup created successfully at: $backupFile" -ForegroundColor Green
        } else {
            Write-Error "Backup failed"
        }
        exit 0
    }
}

# Restore functionality
if ($Restore) {
    if (-not $RestoreFile) {
        # If no specific file provided, show available backups
        $backupFolder = $config.Folders.Backups
        $backups = Get-ChildItem -Path $backupFolder -Filter "MarkSnips_Backup_*.zip" | Sort-Object -Property LastWriteTime -Descending
        
        if ($backups.Count -eq 0) {
            Write-Error "No backups found in $backupFolder"
            exit 1
        }
        
        Write-Host "Available backups:" -ForegroundColor Cyan
        for ($i = 0; $i -lt $backups.Count; $i++) {
            Write-Host "$($i + 1). $($backups[$i].Name) ($(Get-Date -Date $backups[$i].LastWriteTime -Format 'yyyy-MM-dd HH:mm:ss'))"
        }
        
        $selection = Read-Host "Enter the number of the backup to restore (or 'q' to quit)"
        if ($selection -eq "q") {
            exit 0
        }
        
        try {
            $index = [int]$selection - 1
            if ($index -ge 0 -and $index -lt $backups.Count) {
                $RestoreFile = $backups[$index].FullName
            } else {
                Write-Error "Invalid selection"
                exit 1
            }
        } catch {
            Write-Error "Invalid selection"
            exit 1
        }
    }
    
    $confirmMessage = "This will replace existing files with content from $RestoreFile"
    if ($PSCmdlet.ShouldProcess($RestoreFile, "Restore from backup")) {
        Write-Host "Restoring from backup: $RestoreFile" -ForegroundColor Yellow
        $result = Restore-MarkSnipsData -BackupFile $RestoreFile -Config $config
        
        if ($result) {
            Write-Host "Restore completed successfully" -ForegroundColor Green
        } else {
            Write-Error "Restore failed"
        }
        
        exit 0
    }
}

# Default action: Run the watcher script
$watcherScript = Join-Path $sourceDir "watch.ps1"
if (-not (Test-Path $watcherScript)) {
    Write-Error "Watcher script not found at $watcherScript"
    exit 1
}

# Import PSAI module
try {
    Import-Module PSAI -ErrorAction Stop
} catch {
    Write-Error "Failed to import PSAI module. Make sure it's installed."
    Write-Verbose "Error details: $($_.Exception.Message)"
    exit 1
}

# Run the watcher script
Write-Host "Starting MarkSnips file watcher..." -ForegroundColor Green

# Pass through common parameters
$commonParams = @{}
foreach ($param in @('Verbose', 'Debug', 'ErrorAction', 'WarningAction', 'InformationAction', 'ErrorVariable', 'WarningVariable', 'InformationVariable', 'OutVariable', 'OutBuffer', 'PipelineVariable')) {
    if ($PSBoundParameters.ContainsKey($param)) {
        $commonParams[$param] = $PSBoundParameters[$param]
    }
}

# Call the watcher script with parameters
& $watcherScript -ConfigPath $configPath @commonParams
</file>

<file path="Source/config.ps1">
# File: ~/Downloads/MarkSnips/Source/config.ps1

# Configuration and backup management module for MarkSnips

function Initialize-MarkSnipsConfig {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $false)]
        [string]$ConfigPath = "$env:USERPROFILE\Downloads\MarkSnips\config.json"
    )
    
    # Default configuration
    $defaultConfig = @{
        Folders       = @{
            Base      = "$env:USERPROFILE\Downloads\MarkSnips"
            Originals = "$env:USERPROFILE\Downloads\MarkSnips\Originals"
            Enhanced  = "$env:USERPROFILE\Downloads\MarkSnips\Enhanced"
            Logs      = "$env:USERPROFILE\Downloads\MarkSnips\Logs"
            Backups   = "$env:USERPROFILE\Downloads\MarkSnips\Backups"
        }
        Files         = @{
            LogFile    = "$env:USERPROFILE\Downloads\MarkSnips\Logs\watcher.log"
            ConfigFile = "$env:USERPROFILE\Downloads\MarkSnips\config.json"
        }
        Watcher       = @{
            FileFilter             = "*.md"
            PollingInterval        = 5  # seconds
            HeartbeatInterval      = 5  # minutes
            ProcessingDelay        = 2  # seconds
            FileTrackingExpiration = 60  # minutes
        }
        AIPrompts     = @{
            EnhancementPrompt = @"
Take the following markdown content and restructure it for better readability, formatting, and consistency:

```markdown
{content}
```
"@
            FilenamePrompt    = @"
Please create a concise, descriptive filename for this markdown document.
The filename should:
1. Clearly summarize the main topic of the document
2. Be between 3-7 words
3. Use only lowercase letters, numbers, and hyphens (no spaces)
4. End with .md extension
5. Be a clean, SEO-friendly URL slug

Here's the document content:

```markdown
{content}
```

Respond with ONLY the filename and nothing else.
"@
        }
        Backup        = @{
            Enabled        = $true
            MaxBackupSets  = 5
            BackupInterval = 24  # hours
            LastBackup     = $null
        }
        Notifications = @{
            Enabled                  = $true
            ShowSuccessNotifications = $true
            ShowErrorNotifications   = $true
        }
    }
    
    # Check if config exists
    if (Test-Path $ConfigPath) {
        Write-Warning "Config file already exists at $ConfigPath"
        if (-not $PSCmdlet.ShouldProcess($ConfigPath, "Overwrite existing configuration")) {
            return Import-MarkSnipsConfig -ConfigPath $ConfigPath
        }
    }
    
    # Ensure the directory exists
    $configDir = Split-Path -Parent $ConfigPath
    if (-not (Test-Path $configDir)) {
        if ($PSCmdlet.ShouldProcess($configDir, "Create directory")) {
            New-Item -Path $configDir -ItemType Directory -Force | Out-Null
        }
    }
    
    # Save the default config
    if ($PSCmdlet.ShouldProcess($ConfigPath, "Create configuration file")) {
        $defaultConfig | ConvertTo-Json -Depth 10 | Set-Content -Path $ConfigPath -Force
        Write-Verbose "Default configuration created at $ConfigPath"
        
        # Ensure all configured folders exist
        foreach ($folder in $defaultConfig.Folders.Values) {
            if (-not (Test-Path $folder)) {
                if ($PSCmdlet.ShouldProcess($folder, "Create folder")) {
                    New-Item -Path $folder -ItemType Directory -Force | Out-Null
                    Write-Verbose "Created folder: $folder"
                }
            }
        }
    }
    
    return $defaultConfig
}

function Import-MarkSnipsConfig {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$ConfigPath = "$env:USERPROFILE\Downloads\MarkSnips\config.json"
    )
    
    if (-not (Test-Path $ConfigPath)) {
        Write-Warning "Config file not found at $ConfigPath. Creating default config."
        return Initialize-MarkSnipsConfig -ConfigPath $ConfigPath
    }
    
    $config = Get-Content -Path $ConfigPath -Raw | ConvertFrom-Json
    
    # Convert to hashtable for easier manipulation
    $configHash = @{}
    
    # Deep convert from PSObject to hashtable
    function ConvertTo-Hashtable {
        param(
            [Parameter(ValueFromPipeline = $true)]
            $InputObject
        )
        
        process {
            if ($null -eq $InputObject) { return $null }
            
            if ($InputObject -is [System.Collections.IEnumerable] -and $InputObject -isnot [string]) {
                $collection = @(
                    foreach ($object in $InputObject) {
                        ConvertTo-Hashtable $object
                    }
                )
                
                Write-Output -NoEnumerate $collection
            } elseif ($InputObject -is [psobject]) {
                $hash = @{}
                
                foreach ($property in $InputObject.PSObject.Properties) {
                    $hash[$property.Name] = ConvertTo-Hashtable $property.Value
                }
                
                $hash
            } else {
                $InputObject
            }
        }
    }
    
    # Convert the config to a hashtable
    $configHash = ConvertTo-Hashtable $config
    
    return $configHash
}

function Export-MarkSnipsConfig {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Config,
        
        [Parameter(Mandatory = $false)]
        [string]$ConfigPath = "$env:USERPROFILE\Downloads\MarkSnips\config.json"
    )
    
    if ($PSCmdlet.ShouldProcess($ConfigPath, "Save configuration")) {
        $Config | ConvertTo-Json -Depth 10 | Set-Content -Path $ConfigPath -Force
        Write-Verbose "Configuration saved to $ConfigPath"
    }
}

function Update-MarkSnipsConfig {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $false)]
        [string]$ConfigPath = "$env:USERPROFILE\Downloads\MarkSnips\config.json",
        
        [Parameter(Mandatory = $true)]
        [string]$PropertyPath,
        
        [Parameter(Mandatory = $true)]
        $Value
    )
    
    # Load current config
    $config = Import-MarkSnipsConfig -ConfigPath $ConfigPath
    
    # Split the property path
    $pathParts = $PropertyPath -split '\.'
    
    # Navigate to the property
    $current = $config
    for ($i = 0; $i -lt $pathParts.Count - 1; $i++) {
        $part = $pathParts[$i]
        
        if (-not $current.ContainsKey($part)) {
            $current[$part] = @{}
        }
        
        $current = $current[$part]
    }
    
    # Set the value
    if ($PSCmdlet.ShouldProcess($PropertyPath, "Update configuration property")) {
        $current[$pathParts[-1]] = $Value
        
        # Save the updated config
        Export-MarkSnipsConfig -Config $config -ConfigPath $ConfigPath
    }
    
    return $config
}

function Backup-MarkSnipsData {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $false)]
        [hashtable]$Config = (Import-MarkSnipsConfig)
    )
    
    # Check if backups are enabled
    if (-not $Config.Backup.Enabled) {
        Write-Verbose "Backups are disabled in configuration."
        return
    }
    
    # Check if we need to perform a backup based on interval
    $lastBackup = $Config.Backup.LastBackup
    $backupInterval = $Config.Backup.BackupInterval
    
    if ($lastBackup) {
        $lastBackupTime = [datetime]::Parse($lastBackup)
        $nextBackupTime = $lastBackupTime.AddHours($backupInterval)
        
        if ((Get-Date) -lt $nextBackupTime) {
            Write-Verbose "Skipping backup - next scheduled backup is at $nextBackupTime"
            return
        }
    }
    
    # Prepare backup folder and filename
    $backupFolder = $Config.Folders.Backups
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
    $backupFile = Join-Path $backupFolder "MarkSnips_Backup_$timestamp.zip"
    
    if (-not (Test-Path $backupFolder)) {
        if ($PSCmdlet.ShouldProcess($backupFolder, "Create backup directory")) {
            New-Item -Path $backupFolder -ItemType Directory -Force | Out-Null
            Write-Verbose "Created backup folder: $backupFolder"
        }
    }
    
    # Create temporary folder for preparing the backup
    $tempFolder = Join-Path $env:TEMP "MarkSnips_Backup_$timestamp"
    if (Test-Path $tempFolder) {
        Remove-Item -Path $tempFolder -Recurse -Force
    }
    New-Item -Path $tempFolder -ItemType Directory -Force | Out-Null
    
    try {
        # Copy files to temp folder
        if ($PSCmdlet.ShouldProcess("MarkSnips data", "Collect for backup")) {
            Copy-Item -Path $Config.Files.ConfigFile -Destination $tempFolder -Force
            Copy-Item -Path (Join-Path $Config.Folders.Originals "*") -Destination $tempFolder -Force -Recurse
            Copy-Item -Path (Join-Path $Config.Folders.Enhanced "*") -Destination $tempFolder -Force -Recurse
            
            # Copy scripts
            $scriptFolder = Join-Path $tempFolder "Scripts"
            New-Item -Path $scriptFolder -ItemType Directory -Force | Out-Null
            
            $scriptFiles = Get-ChildItem -Path (Split-Path -Parent $Config.Files.ConfigFile) -Filter "*.ps1" -File
            foreach ($scriptFile in $scriptFiles) {
                Copy-Item -Path $scriptFile.FullName -Destination $scriptFolder -Force
            }
        }
        
        # Create the zip file
        if ($PSCmdlet.ShouldProcess($backupFile, "Create backup archive")) {
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            [System.IO.Compression.ZipFile]::CreateFromDirectory($tempFolder, $backupFile)
            
            Write-Verbose "Backup created successfully: $backupFile"
            
            # Update last backup time in config
            $Config.Backup.LastBackup = (Get-Date).ToString("o")
            Export-MarkSnipsConfig -Config $Config
            
            # Clean up old backups
            $allBackups = Get-ChildItem -Path $backupFolder -Filter "MarkSnips_Backup_*.zip" | Sort-Object -Property LastWriteTime -Descending
            if ($allBackups.Count -gt $Config.Backup.MaxBackupSets) {
                $backupsToRemove = $allBackups | Select-Object -Skip $Config.Backup.MaxBackupSets
                foreach ($backup in $backupsToRemove) {
                    if ($PSCmdlet.ShouldProcess($backup.FullName, "Remove old backup")) {
                        Remove-Item -Path $backup.FullName -Force
                        Write-Verbose "Removed old backup: $($backup.Name)"
                    }
                }
            }
        }
        
        return $backupFile
    } catch {
        Write-Error "Failed to create backup: $($_.Exception.Message)"
        return $null
    } finally {
        # Clean up temp folder
        if (Test-Path $tempFolder) {
            Remove-Item -Path $tempFolder -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
}

function Restore-MarkSnipsData {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $true)]
        [string]$BackupFile,
        
        [Parameter(Mandatory = $false)]
        [hashtable]$Config = (Import-MarkSnipsConfig)
    )
    
    if (-not (Test-Path $BackupFile)) {
        Write-Error "Backup file not found: $BackupFile"
        return $false
    }
    
    # Create temporary extraction folder
    $tempFolder = Join-Path $env:TEMP "MarkSnips_Restore_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
    if (Test-Path $tempFolder) {
        Remove-Item -Path $tempFolder -Recurse -Force
    }
    New-Item -Path $tempFolder -ItemType Directory -Force | Out-Null
    
    try {
        # Extract backup
        if ($PSCmdlet.ShouldProcess($BackupFile, "Extract backup archive")) {
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            [System.IO.Compression.ZipFile]::ExtractToDirectory($BackupFile, $tempFolder)
            
            # Restore configuration
            $configFile = Get-ChildItem -Path $tempFolder -Filter "config.json" -File -Recurse | Select-Object -First 1
            if ($configFile) {
                Copy-Item -Path $configFile.FullName -Destination $Config.Files.ConfigFile -Force
                $Config = Import-MarkSnipsConfig
            }
            
            # Ensure all target folders exist
            foreach ($folder in $Config.Folders.Values) {
                if (-not (Test-Path $folder)) {
                    New-Item -Path $folder -ItemType Directory -Force | Out-Null
                }
            }
            
            # Restore Originals folder
            $originalsSource = Join-Path $tempFolder "Originals"
            if (Test-Path $originalsSource) {
                Copy-Item -Path (Join-Path $originalsSource "*") -Destination $Config.Folders.Originals -Force -Recurse
            }
            
            # Restore Enhanced folder
            $enhancedSource = Join-Path $tempFolder "Enhanced"
            if (Test-Path $enhancedSource) {
                Copy-Item -Path (Join-Path $enhancedSource "*") -Destination $Config.Folders.Enhanced -Force -Recurse
            }
            
            # Restore scripts
            $scriptSource = Join-Path $tempFolder "Scripts"
            if (Test-Path $scriptSource) {
                $scriptDestination = Split-Path -Parent $Config.Files.ConfigFile
                Copy-Item -Path (Join-Path $scriptSource "*") -Destination $scriptDestination -Force -Recurse
            }
            
            Write-Verbose "Restore completed successfully from $BackupFile"
            return $true
        }
    } catch {
        Write-Error "Failed to restore from backup: $($_.Exception.Message)"
        return $false
    } finally {
        # Clean up temp folder
        if (Test-Path $tempFolder) {
            Remove-Item -Path $tempFolder -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
}
</file>

<file path="Source/enhance.ps1">
Import-Module PSAI

Function Invoke-AIEnhanceMarkdown {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$InputFile,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputFile,
        
        [Parameter(Mandatory = $false)]
        [switch]$OpenWhenDone,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputFolder,
        
        [Parameter(Mandatory = $false)]
        [switch]$ProcessFolder,
        
        [Parameter(Mandatory = $false)]
        [string]$FilePattern = "*.md"
    )
    
    begin {
        # Set up the output folder if specified
        if ($OutputFolder -and -not (Test-Path $OutputFolder)) {
            New-Item -Path $OutputFolder -ItemType Directory -Force | Out-Null
            Write-Verbose "Created output folder: $OutputFolder"
        }
        
        # Track statistics
        $stats = @{
            Processed = 0
            Success   = 0
            Failed    = 0
        }
    }
    
    process {
        # If we're processing a folder, handle that
        if ($ProcessFolder) {
            if (Test-Path $InputFile -PathType Container) {
                $files = Get-ChildItem -Path $InputFile -Filter $FilePattern -File
                foreach ($file in $files) {
                    try {
                        $result = ProcessSingleFile -InputFile $file.FullName -OutputFolder $OutputFolder -OpenWhenDone:$OpenWhenDone
                        if ($result) {
                            $stats.Processed++
                            $stats.Success++
                        }
                    } catch {
                        Write-Error "Failed to process $($file.FullName): $($_.Exception.Message)"
                        $stats.Processed++
                        $stats.Failed++
                    }
                }
                return $stats
            } else {
                Write-Error "The specified path is not a directory: $InputFile"
                return $null
            }
        }
        
        # Otherwise process a single file
        try {
            $result = ProcessSingleFile -InputFile $InputFile -OutputFile $OutputFile -OutputFolder $OutputFolder -OpenWhenDone:$OpenWhenDone
            if ($result) {
                $stats.Processed++
                $stats.Success++
            }
            return $result
        } catch {
            Write-Error "Failed to process $($InputFile): $($_.Exception.Message)"
            $stats.Processed++
            $stats.Failed++
            return $null
        }
    }
    
    end {
        if ($ProcessFolder) {
            Write-Host "Processing complete: $($stats.Processed) files processed, $($stats.Success) succeeded, $($stats.Failed) failed."
        }
    }
}

function ProcessSingleFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$InputFile,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputFile,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputFolder,
        
        [Parameter(Mandatory = $false)]
        [switch]$OpenWhenDone
    )
    
    # Resolve full path and validate input file exists
    $inputFilePath = Resolve-Path $InputFile
    Write-Verbose "Processing file: $inputFilePath"
    
    # Determine output file path
    if (-not $OutputFile) {
        if ($OutputFolder) {
            $fileName = Split-Path $InputFile -Leaf
            $OutputFile = Join-Path $OutputFolder $fileName
        } else {
            $OutputFile = $InputFile -replace '\.md$', '-enhanced.md'
        }
    }
    
    # Read content
    $content = Get-Content -Path $inputFilePath -Raw
    
    # Define newline
    $nl = [Environment]::NewLine
    
    # Use a here-string for the prompt with correctly escaped backticks
    $prompt = @"
Take the following markdown content and restructure it for better readability, formatting, and consistency:

```markdown
$content
```
"@

    # Make the API call
    Write-Verbose "Calling AI service..."
    try {
        $enhanced = Invoke-OAIChat $prompt
        $enhancedSplitted = $enhanced.Split("`n")[1..($enhanced.Split("`n").Length - 2)] -join "`n"
        $enhancedContent = $enhancedSplitted
    } catch {
        Write-Error "AI service error: $($_.Exception.Message)"
        return $null
    }

    # Create or overwrite the output file
    if (Test-Path $OutputFile) {
        Remove-Item $OutputFile -Force
    } else {
        $outputDir = Split-Path -Parent $OutputFile
        if (-not [string]::IsNullOrEmpty($outputDir) -and -not (Test-Path $outputDir)) {
            New-Item -Path $outputDir -ItemType Directory -Force | Out-Null
        }
        New-Item -Path $OutputFile -ItemType File -Force | Out-Null
    }

    # Write content
    Set-Content -Path $OutputFile -Value $enhancedContent -Force
    Write-Verbose "Successfully wrote enhanced content to: $OutputFile"

    # Open the file if requested
    if ($OpenWhenDone) {
        Start-Process $OutputFile
    }

    # Return the file path
    return $OutputFile
}

# Add an alias for convenience
Set-Alias -Name Enhance-Markdown -Value Invoke-AIEnhanceMarkdown

# For use in Task Scheduler, add this sample command
function Invoke-ScheduledMarkdownEnhancement {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$SnippetsFolder = "$env:USERPROFILE\Downloads\MarkSnips",
        
        [Parameter(Mandatory = $false)]
        [string]$OutputFolder = "$env:USERPROFILE\Downloads\MarkSnips\Enhanced",
        
        [Parameter(Mandatory = $false)]
        [string]$LogFile = "$env:USERPROFILE\Downloads\MarkSnips\enhancement_log.txt"
    )
    
    # Ensure the folders exist
    if (-not (Test-Path $SnippetsFolder)) {
        New-Item -Path $SnippetsFolder -ItemType Directory -Force | Out-Null
    }
    
    if (-not (Test-Path $OutputFolder)) {
        New-Item -Path $OutputFolder -ItemType Directory -Force | Out-Null
    }
    
    # Start logging
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "[$timestamp] Starting scheduled markdown enhancement" | Out-File -FilePath $LogFile -Append
    
    try {
        # Find all unprocessed markdown files
        $files = Get-ChildItem -Path $SnippetsFolder -Filter "*.md" -File | 
            Where-Object { $_.FullName -notlike "*-enhanced.md" -and $_.FullName -notlike "*.backup.md" }
        
        "[$timestamp] Found $($files.Count) files to process" | Out-File -FilePath $LogFile -Append
        
        # Process each file
        foreach ($file in $files) {
            $fileTimestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            try {
                "[$fileTimestamp] Processing: $($file.Name)" | Out-File -FilePath $LogFile -Append
                
                $outputPath = Join-Path $OutputFolder $file.Name
                Invoke-AIEnhanceMarkdown -InputFile $file.FullName -OutputFile $outputPath
                
                "[$fileTimestamp] Successfully enhanced: $($file.Name)" | Out-File -FilePath $LogFile -Append
            } catch {
                "[$fileTimestamp] ERROR processing $($file.Name): $($_.Exception.Message)" | Out-File -FilePath $LogFile -Append
            }
        }
    } catch {
        "[$timestamp] ERROR in main process: $($_.Exception.Message)" | Out-File -FilePath $LogFile -Append
    }
    
    $endTimestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "[$endTimestamp] Completed scheduled markdown enhancement" | Out-File -FilePath $LogFile -Append
}
</file>

<file path="Source/watch.ps1">
# File: ~/Downloads/MarkSnips/Source/watch.ps1
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    [Parameter(Mandatory = $false)]
    [string]$ConfigPath = "$env:USERPROFILE\Downloads\MarkSnips\config.json",
    
    [Parameter(Mandatory = $false)]
    [switch]$BackupNow
)

# Import required scripts
$scriptRoot = $PSScriptRoot
$configModule = Join-Path $scriptRoot "config.ps1"
$enhanceModule = Join-Path $scriptRoot "enhance.ps1"

# Source the scripts
. $configModule
. $enhanceModule

# Import PSAI module
Import-Module PSAI

# Load or initialize configuration
$config = Import-MarkSnipsConfig -ConfigPath $ConfigPath
if (-not $config) {
    $config = Initialize-MarkSnipsConfig -ConfigPath $ConfigPath
    Write-Host "Created new configuration file at $ConfigPath" -ForegroundColor Green
}

# Extract configuration values
$baseFolder = $config.Folders.Base
$originalFolder = $config.Folders.Originals
$enhancedFolder = $config.Folders.Enhanced
$logDir = $config.Folders.Logs
$logFile = $config.Files.LogFile
$fileFilter = $config.Watcher.FileFilter
$pollingInterval = $config.Watcher.PollingInterval
$heartbeatInterval = $config.Watcher.HeartbeatInterval
$processingDelay = $config.Watcher.ProcessingDelay
$fileTrackingExpiration = $config.Watcher.FileTrackingExpiration

# Run immediate backup if requested
if ($BackupNow) {
    if ($PSCmdlet.ShouldProcess("MarkSnips data", "Create backup")) {
        Write-Host "Creating backup..." -ForegroundColor Yellow
        $backupPath = Backup-MarkSnipsData -Config $config
        if ($backupPath) {
            Write-Host "Backup created successfully at: $backupPath" -ForegroundColor Green
        } else {
            Write-Host "Backup failed" -ForegroundColor Red
        }
    }
}

# Ensure log directory exists
if (-not (Test-Path $logDir)) {
    New-Item -Path $logDir -ItemType Directory -Force | Out-Null
}

function Write-Log {
    param(
        [string]$Message,
        [switch]$Warning,
        [switch]$IsError
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] $Message"
    
    # Log to file
    $logMessage | Out-File -Append -FilePath $logFile
    
    # Log to console with appropriate color
    if ($IsError) {
        Write-Host $logMessage -ForegroundColor Red
    } elseif ($Warning) {
        Write-Host $logMessage -ForegroundColor Yellow
    } else {
        Write-Host $logMessage
        Write-Verbose $Message
    }
}

function Show-Notification {
    param(
        [string]$Title,
        [string]$Message
    )
    
    # Check if notifications are enabled in config
    if (-not $config.Notifications.Enabled) {
        return
    }
    
    # For success notifications, check if they're enabled
    if ($Title -like "*Success*" -and -not $config.Notifications.ShowSuccessNotifications) {
        return
    }
    
    # For error notifications, check if they're enabled
    if ($Title -like "*Error*" -and -not $config.Notifications.ShowErrorNotifications) {
        return
    }
    
    try {
        # Try Windows 10/11 notification API
        Add-Type -AssemblyName System.Windows.Forms
        $notification = New-Object System.Windows.Forms.NotifyIcon
        $notification.Icon = [System.Drawing.SystemIcons]::Information
        $notification.BalloonTipTitle = $Title
        $notification.BalloonTipText = $Message
        $notification.Visible = $true
        $notification.ShowBalloonTip(5000)
        
        # Force garbage collection to prevent icon persisting
        [System.GC]::Collect()
        Write-Log "Notification displayed: $Title - $Message"
    } catch {
        Write-Log "Failed to display notification: $($_.Exception.Message)" -Warning
    }
}

function Get-AIGeneratedFileName {
    param(
        [string]$FilePath,
        [string]$OriginalName
    )
    
    try {
        # Read the content of the file
        $fileContent = Get-Content -Path $FilePath -Raw
        
        # Get the filename prompt from config and replace the content placeholder
        $prompt = $config.AIPrompts.FilenamePrompt -replace '\{content\}', $fileContent
        
        Write-Log "Requesting AI to generate filename for: $OriginalName"
        
        # Call OpenAI to generate a filename
        $aiResponse = Invoke-OAIChat $prompt -ErrorAction Stop
        
        # Clean up the response (just in case it contains extra text)
        $aiFilename = $aiResponse.Trim()
        
        # Ensure it has .md extension
        if (-not $aiFilename.EndsWith('.md')) {
            $aiFilename = $aiFilename + '.md'
        }
        
        # Add date prefix
        $datePrefix = Get-Date -Format "yyyy-MM-dd"
        $finalName = "$datePrefix-$aiFilename"
        
        # Replace any invalid characters that AI might have included
        $finalName = $finalName -replace '[\\/:*?"<>|]', '-'
        
        Write-Log "AI generated filename: $finalName"
        return $finalName
    } catch {
        # If AI rename fails, fall back to date-based naming
        Write-Log "Failed to generate AI filename: $($_.Exception.Message)" -Warning
        
        # Remove common prefix patterns and clean up
        $cleanName = $OriginalName -replace '^MarkSnips_', ''
        $cleanName = $cleanName -replace '[-_\s]', '-'
        
        # Add date prefix
        $datePrefix = Get-Date -Format "yyyy-MM-dd"
        return "$datePrefix-$cleanName"
    }
}

function Process-MarkdownFile {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [string]$FilePath
    )
    
    $name = Split-Path $FilePath -Leaf
    
    # Skip files that appear to be enhanced versions or in subdirectories
    if ($name -like "README.md" -or
        $name -like "CHANGELOG.md" -or
        $name -like "*-enhanced.md" -or 
        $name -like "*.backup.md" -or 
        $FilePath -like "*\Enhanced\*" -or 
        $FilePath -like "*\Originals\*" -or 
        $name -eq "watcher-test-file.tmp") {
        
        Write-Log "Skipping processing for: $name"
        return
    }
    
    if (-not $PSCmdlet.ShouldProcess($name, "Process markdown file")) {
        return
    }
    
    try {
        # First make sure we have access to the file
        $fileContent = Get-Content -Path $FilePath -Raw
        Write-Log "File content accessed successfully"
        
        # Copy to originals first
        $originalPath = Join-Path $originalFolder $name
        Copy-Item -Path $FilePath -Destination $originalPath -Force
        Write-Log "Copied original file to: $originalPath"
        
        # Get AI-generated filename
        $aiFilename = Get-AIGeneratedFileName -FilePath $originalPath -OriginalName $name
        $enhancedPath = Join-Path $enhancedFolder $aiFilename
        
        Write-Log "Processing file from original location: $originalPath -> $enhancedPath"
        
        # Get the enhancement prompt from config and replace the content placeholder
        $prompt = $config.AIPrompts.EnhancementPrompt -replace '\{content\}', $fileContent
        
        # Call the enhancement function
        $enhancedContent = Invoke-OAIChat $prompt
        
        # Process the response - strip code fences
        $enhancedLines = $enhancedContent.Split("`n")
        $startIndex = 0
        $endIndex = $enhancedLines.Length - 1
        
        # Check for code fences
        if ($enhancedLines[0] -match "^```markdown" -or $enhancedLines[0] -match "^```$") {
            $startIndex = 1
        }
        if ($enhancedLines[$endIndex] -match "^```$") {
            $endIndex -= 1
        }
        
        # Join without code fences
        $cleanContent = $enhancedLines[$startIndex..$endIndex] -join "`n"
        
        # Create output file
        if (Test-Path $enhancedPath) {
            Remove-Item $enhancedPath -Force
        }
        Set-Content -Path $enhancedPath -Value $cleanContent -Force
        
        # Now remove the original from the watch folder
        if (Test-Path $FilePath) {
            Remove-Item -Path $FilePath -Force
            Write-Log "Removed original file from watch folder"
        } else {
            Write-Log "Original file no longer exists in watch folder" -Warning
        }
        
        Write-Log "Successfully enhanced: $name -> $aiFilename"
        
        # Show notification
        Show-Notification -Title "Markdown Enhanced" -Message "Successfully enhanced: $aiFilename"
        
        return $true
    } catch {
        Write-Log "ERROR processing $name`: $($_.Exception.Message)" -IsError
        Show-Notification -Title "Enhancement Error" -Message "Failed to process: $name"
        return $false
    }
}

# Ensure folders exist
foreach ($folder in @($baseFolder, $originalFolder, $enhancedFolder, $logDir)) {
    if (-not (Test-Path $folder)) {
        if ($PSCmdlet.ShouldProcess($folder, "Create folder")) {
            Write-Log "Creating folder: $folder"
            New-Item -Path $folder -ItemType Directory -Force | Out-Null
            
            # Verify folder was created successfully
            if (Test-Path $folder) {
                Write-Log "Folder created successfully: $folder"
            } else {
                Write-Log "Failed to create folder: $folder" -IsError
            }
        }
    } else {
        Write-Verbose "Folder already exists: $folder"
    }
}

Write-Log "=== Starting file watcher ==="
Write-Log "Monitoring folder: $baseFolder"
Write-Log "Log file: $logFile"
Write-Log "Config file: $ConfigPath"

# Write the correct paths to confirm they're working
Write-Verbose "Current folder ($PWD): $PWD"
Write-Verbose "PSScriptRoot: $PSScriptRoot"
Write-Verbose "Base folder: $baseFolder"
Write-Verbose "Enhanced folder: $enhancedFolder"
Write-Verbose "Originals folder: $originalFolder"

# Starting polling-based watcher
Write-Log "Starting polling-based file watcher"
Show-Notification -Title "Markdown Watcher Active" -Message "Monitoring for new files in: $baseFolder"

# Check if backup is needed on startup
if ($config.Backup.Enabled) {
    $lastBackup = $config.Backup.LastBackup
    $backupNeeded = $false
    
    if (-not $lastBackup) {
        $backupNeeded = $true
    } else {
        $lastBackupTime = [datetime]::Parse($lastBackup)
        $nextBackupTime = $lastBackupTime.AddHours($config.Backup.BackupInterval)
        if ((Get-Date) -gt $nextBackupTime) {
            $backupNeeded = $true
        }
    }
    
    if ($backupNeeded) {
        if ($PSCmdlet.ShouldProcess("MarkSnips data", "Perform scheduled backup")) {
            Write-Log "Performing scheduled backup"
            $backupFile = Backup-MarkSnipsData -Config $config
            if ($backupFile) {
                Write-Log "Backup created: $backupFile"
            } else {
                Write-Log "Backup failed" -IsError
            }
        }
    }
}

# Process existing files on startup
$existingFiles = Get-ChildItem -Path $baseFolder -Filter $fileFilter -File | 
    Where-Object { $_.FullName -notlike "*\Enhanced\*" -and $_.FullName -notlike "*\Originals\*" }

if ($existingFiles.Count -gt 0) {
    Write-Log "Found $($existingFiles.Count) existing files to process on startup"
    
    foreach ($file in $existingFiles) {
        Process-MarkdownFile -FilePath $file.FullName
    }
}

# Create a hashtable to keep track of processed files
$processedFiles = @{}

try {
    # Main monitoring loop
    while ($true) {
        # Get current files in the watch folder
        $currentFiles = Get-ChildItem -Path $baseFolder -Filter $fileFilter -File | 
            Where-Object { $_.FullName -notlike "*\Enhanced\*" -and $_.FullName -notlike "*\Originals\*" }
        
        # Log file count but only when verbose or files exist
        if ($VerbosePreference -eq 'Continue' -or $currentFiles.Count -gt 0) {
            Write-Verbose "Checking for new files. Found $($currentFiles.Count) files in watch folder."
        }
        
        # Process any new files
        foreach ($file in $currentFiles) {
            # If we haven't seen this file before
            if (-not $processedFiles.ContainsKey($file.FullName)) {
                Write-Log "New file detected: $($file.Name)"
                
                # Add to processed files list
                $processedFiles[$file.FullName] = (Get-Date)
                
                # Process the file
                Process-MarkdownFile -FilePath $file.FullName
            }
        }
        
        # Clean up processed files list (remove entries older than tracking expiration)
        $cutoffTime = (Get-Date).AddMinutes(-$fileTrackingExpiration)
        $keysToRemove = $processedFiles.Keys | Where-Object { $processedFiles[$_] -lt $cutoffTime }
        
        foreach ($key in $keysToRemove) {
            $processedFiles.Remove($key)
            Write-Verbose "Removed old entry from processed files tracking: $key"
        }
        
        # Heartbeat logging
        $currentMinute = (Get-Date).Minute
        if ($currentMinute % $heartbeatInterval -eq 0 -and (Get-Date).Second -lt 10) {
            Write-Log "Watcher still active... (heartbeat check)"
        }
        
        # Sleep to prevent CPU overuse
        Start-Sleep -Seconds $pollingInterval
    }
} finally {
    Write-Log "File monitoring stopped."
    Show-Notification -Title "Markdown Watcher Stopped" -Message "File monitoring has been stopped."
}
</file>

</files>
